import subprocess
import os
from pathlib import Path

Import('env', 'arch', 'common', 'messaging', 'visionipc', 'replay_lib', 'cereal')

qt_env = env.Clone()

# Configure build directory
build_dir = Dir('#build').abspath
qt_env['QT_MOCFROMHDIR'] = os.path.join(build_dir, 'moc')
qt_env['QT_MOCFROMCXXDIR'] = os.path.join(build_dir, 'moc')

qt_env["CPPPATH"] += ["#"]
qt_modules = ["Widgets", "Gui", "Core", "Concurrent", "DBus", "Xml", "Svg", "OpenGL", "OpenGLWidgets", "PrintSupport", "Charts", "SerialBus"]

qt_libs = []
qt_host_bins = ""

if arch == "Darwin":
    brew_prefix = subprocess.check_output(['brew', '--prefix'], encoding='utf8').strip()
    qt_env['QTDIR'] = f"{brew_prefix}/opt/qt@6"
    qt_dirs = [os.path.join(qt_env['QTDIR'], "include")]
    qt_framework_dirs = [os.path.join(qt_env['QTDIR'], "lib"), os.path.join(brew_prefix, "lib")]

    for m in qt_modules:
        qt_mod_include = Path(qt_env['QTDIR']) / "include" / f"Qt{m}"
        qt_framework_header = Path(qt_env['QTDIR']) / "lib" / f"Qt{m}.framework" / "Headers"
        brew_framework_header = Path(brew_prefix) / "lib" / f"Qt{m}.framework" / "Headers"
        if qt_mod_include.exists():
            qt_dirs.append(str(qt_mod_include))
        elif qt_framework_header.exists():
            qt_dirs.append(str(qt_framework_header))
        elif brew_framework_header.exists():
            qt_dirs.append(str(brew_framework_header))

    # Homebrew Qt frameworks can miss QtCore/... style include paths.
    # Create a small include shim under build/ to keep includes portable.
    qt_headers_root = Path(build_dir) / "qt_headers"
    qt_headers_root.mkdir(parents=True, exist_ok=True)
    for m in qt_modules:
        header_candidates = [
            Path(qt_env['QTDIR']) / "lib" / f"Qt{m}.framework" / "Headers",
            Path(brew_prefix) / "lib" / f"Qt{m}.framework" / "Headers",
        ]
        header_dir = next((p for p in header_candidates if p.exists()), None)
        if header_dir is None:
            continue
        link_path = qt_headers_root / f"Qt{m}"
        if link_path.is_symlink() and os.readlink(link_path) == str(header_dir):
            continue
        if link_path.exists() or link_path.is_symlink():
            link_path.unlink()
        os.symlink(str(header_dir), str(link_path))
    qt_dirs.append(str(qt_headers_root))

    qt_env["LINKFLAGS"] += ["-F" + d for d in qt_framework_dirs]
    qt_env["CCFLAGS"] += ["-F" + d for d in qt_framework_dirs]
    qt_env["FRAMEWORKS"] += [f"Qt{m}" for m in qt_modules] + ["OpenGL"]
    qt_env.AppendENVPath('PATH', os.path.join(qt_env['QTDIR'], "bin"))
    qt_host_bins = os.path.join(qt_env['QTDIR'], "bin")
    if not Path(qt_host_bins, "moc").exists():
        qt_host_bins = os.path.join(qt_env['QTDIR'], "share", "qt", "libexec")
else:
    # Use qmake6 to find paths
    qt_install_prefix = subprocess.check_output(['qmake6', '-query', 'QT_INSTALL_PREFIX'], encoding='utf8').strip()
    qt_install_headers = subprocess.check_output(['qmake6', '-query', 'QT_INSTALL_HEADERS'], encoding='utf8').strip()
    qt_host_bins = subprocess.check_output(['qmake6', '-query', 'QT_HOST_BINS'], encoding='utf8').strip()

    # Validation for Ubuntu/Debian 'libexec' vs 'bin'
    if not os.path.exists(os.path.join(qt_host_bins, 'moc')):
        if os.path.exists('/usr/lib/qt6/libexec/moc'):
            qt_host_bins = '/usr/lib/qt6/libexec'

    qt_env['QTDIR'] = qt_install_prefix
    qt_dirs = [qt_install_headers]

    # Handle Private QPA headers if necessary
    qt_gui_path = os.path.join(qt_install_headers, "QtGui")
    if os.path.exists(qt_gui_path):
        qt_gui_dirs = [d for d in os.listdir(qt_gui_path) if os.path.isdir(os.path.join(qt_gui_path, d))]
        qt_dirs += [f"{qt_install_headers}/QtGui/{qt_gui_dirs[0]}/QtGui"] if qt_gui_dirs else []

    qt_dirs += [f"{qt_install_headers}/Qt{m}" for m in qt_modules]
    qt_libs = [f"Qt6{m}" for m in qt_modules]

    if arch == "larch64":
        qt_libs += ["GLESv2", "wayland-client"]
    else:
        qt_libs += ["GL"]

# Load the tool first, then immediately overwrite its broken path assumptions
qt_env['QT3DIR'] = qt_env['QTDIR']
qt_env.Tool('qt3')

# Define absolute paths to binaries
moc_bin = os.path.join(qt_host_bins, 'moc')

uic_bin = os.path.join(qt_host_bins, 'uic')
rcc_bin = os.path.join(qt_host_bins, 'rcc')

# Replace the command templates that SCons uses internally
qt_env.Replace(
    QT_MOC = moc_bin,
    QT_UIC = uic_bin,
    RCC = rcc_bin,
    MOC = moc_bin,
    UIC = uic_bin,
    # Overwrite the command strings to ensure they don't prepend $QTDIR/bin
   QT3_MOC = moc_bin,
)

qt_env['CPPPATH'] += qt_dirs + ["#src", "#src/widgets", "#src/streams", "#src/dbc", "#src/chart", "#src/tools", "#src/utils"]

qt_flags = [
    "-D_REENTRANT", "-DQT_NO_DEBUG", "-DQT_WIDGETS_LIB", "-DQT_GUI_LIB",
    "-DQT_CORE_LIB", "-DQT_SVG_LIB", "-DQT_MESSAGELOGCONTEXT",
    "-Wno-deprecated-enum-enum-conversion",
]
qt_env['CXXFLAGS'] += qt_flags

base_frameworks = qt_env.get('FRAMEWORKS', [])
base_libs = [common, messaging, cereal, visionipc, 'm', 'ssl', 'crypto', 'pthread'] + qt_libs

if arch == "Darwin":
    base_frameworks += ['OpenCL', 'QtCharts', 'QtSerialBus']
else:
    base_libs += ['OpenCL', 'Qt6Charts', 'Qt6SerialBus']

cabana_env = qt_env.Clone()
cabana_env.VariantDir('#build', '.', duplicate=0)

# Build assets using the verified RCC path
assets = "#build/assets/assets.cc"
assets_src = "#/resources.qrc"
cabana_env.Command(assets, assets_src, f"$RCC $SOURCES -o $TARGET")
cabana_env.Depends(assets, [assets_src] + Glob('assets/*.svg'))

src_files = Glob('#src/*.cc') + Glob('#src/*/*.cc') + Glob('#src/*/*/*.cc') + Glob('#src/*/*/*/*.cc')
src_file_strings = ['#build/' + str(f) for f in src_files if f != 'main.cc']

cabana_libs = [cereal, messaging, visionipc, replay_lib, 'avutil', 'avcodec', 'avformat', 'swscale','bz2', 'zstd', 'curl', 'usb-1.0'] + base_libs

cabana_lib = cabana_env.Library(
    "#build/cabana_lib",
    src_file_strings,
    LIBS=cabana_libs,
    FRAMEWORKS=base_frameworks,
)
cabana_env.Program('#cabana', ['#build/main.cc', cabana_lib, assets], LIBS=cabana_libs, FRAMEWORKS=base_frameworks)
